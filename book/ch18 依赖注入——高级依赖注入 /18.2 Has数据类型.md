# 18.2 Has数据类型
这些挑战导致ZLayer的出现以及支持它的数据类型Has的出现。
您可以将Has视为从服务类型到服务实现的映射。 例如，`Has [Console]`将被表示为以下形式：
`Map（ConsoleServiceType-> ConsoleServiceImplementation）`
ConsoleServiceType是一个Tag，类似于Scala标准库中的ClassTag或TypeTag，因为它在运行时捕获类型信息。 但是，它提供了一致的跨版本和跨平台接口，并支持参数化类型，这使其比直接使用ClassTag和TypeTag更方便。
Has数据类型使我们能够解决上面讨论的组成多个服务的问题，因为虽然我们不知道如何组合两种类型，但是却知道如何组合两个Map！
为了了解其工作原理，让我们考虑一下将`Has [Database]`与`Has [Logging]`结合起来会发生什么。
`Has [Database]`和`Has [Logging]`服务看起来像这样：
```
Map[DatabaseServiceType -> DatabaseServiceImplementation]
Map[LoggingServiceType -> LoggingServiceImplementation]
```
鉴于此，至少在概念上，使`用Has [Logging]`实现`Has [Database]`变得相对简单。
如果我们要求`Has [Database]`提供数据库服务，它可以为我们提供该服务的实际实现。 如果我们要求`Has [Logging]`提供日志记录服务，它可以为我们提供日志记录服务的实际实现。
因此，具有`Has [Logging]`的`Has [Database]`只是意味着我们可以请求数据库服务并获取数据库服务，还可以请求日志记录服务并获取日志服务。
我们可以简单地通过组合两个地图来实现。 因此，具有`Has [Logging]`的`Has [Database]`可以这样实现：
```
Map(
    DatabaseServiceType -> DatabaseServiceImplementation, 
    LoggingServiceType -> LoggingServiceImplementation
)
```
通过组合来自两个原始Has值基础的映射的键和值，我们可以非常轻松地创建此映射。
使用Has时要记住的一件事是，与许多数据类型不同，它是不变的。 出于技术原因，这是必需的，因此`Has [A]`和`Has [B]`的父类型是具有`Has [B]`的`Has [A]`而不是具有`[B]`的`Has [A]`。
在大多数情况下，这没有什么区别，但有时可能需要做更多的工作才能使类型对齐，因此需要注意。

