# 18.4 水平组合和垂直组合
现在，我们知道了如何以一种通用的方式来实现各个服务，从而使它们得以组合。在实践中，我们如何进行这种组合，特别是当我们拥有可能相互依赖的多个服务时？
为了回答这个问题，区分不同服务可以关联的两种方式是有帮助的。
首先，服务可能会垂直组合。这意味着较高级别的服务取决于较低级别的服务。
例如，我们对数据库服务的实现可能描述了位于远程服务上的数据库。在这种情况下，我们甚至可能需要连接服务才能创建数据库服务。
我们将这种类型的组合称为垂直类型，因为在我们的应用程序中描述更接近于问题域的更复杂逻辑的更高层依赖于更接近实现细节的更低层。
其次，服务可能是水平组合的，这意味着更高级别的应用程序需要这两种服务。在正在运行的示例中，我们一直在使用数据库和日志记录服务，这些服务是水平组合的，因为我们都需要它们，但是它们中的任何一个都没有另一个依赖。
当然，有时服务可以垂直和水平组合。例如，我们的应用程序可能需要数据库和日志记录服务，然后数据库服务本身也可能需要日志记录服务。
垂直和水平组合之间的区别是有帮助的，因为它允许我们使用ZLayer将一组依赖关系之间的关系的逻辑描述相对机械地转换为代码。

第一步，我们将应用程序中的每个服务表示为ZLayer，对每个服务直接依赖的任何服务进行显式建模，作为每个ZLayer的RIn类型的一部分。 我们无需担心某个服务会通过另一个服务间接依赖的服务，因为我们将在层构建过程中选择这些依赖关系。
为了说明这一点，让我们看一下上面描述的示例，其中我们的应用程序依赖于数据库服务和日志记录服务，而数据库服务本身依赖于对日志记录服务的访问。
我们从实现描述如何构造这些服务中的每一个的层开始。 由于数据库层依赖于日志记录层，因此我们在类型签名中使该依赖关系明确。

```
val databaseLayer: ZLayer[Logging, Nothing, Database] = ???
val loggingLayer: ZLayer[Any, Nothing, Logging] = ???
```

接下来，我们使用两个简单的规则“连接”图层。如果我们水平组合两个或多个图层，则使用++运算符。 例如，由于我们的应用程序同时需要数据库和日志记录服务，因此我们使用++将它们组合在一起。
这将创建一个新的ZLayer，它需要两层的输入并产生两层的输出。
```
val horizontallyComposed: ZLayer[Logging, Nothing, Database with Logging] = databaseLayer ++ loggingLayer
```
如果我们垂直组成两层，则将>>>运算符与“较低层”层或提供左侧另一层需要的层一起使用。
例如，由于数据库层取决于日志记录层，因此我们将它们组合如下：

```
val verticallyComposed: ZLayer[Any, Nothing, Database] =
  loggingLayer >>> databaseLayer // 将日记注入数据库
```
这将返回一个新层，该层需要第一层的所有输入并产生第二层的所有输出。 第一层必须产生第二层所需的所有服务。
您可以将>>>视为图层的功能组合。 如果我们有一个需要A并产生B的层并将其与需要B并产生C的层粘合在一起，我们将得到一个新的层，该层需要A并产生C。
要完成此过程，我们必须使用++和>>>对所有垂直和水平组合的层进行建模。
通常，执行此操作的顺序并不重要。
例如，如果我们查看horizontallyComposed的类型签名，我们可以看到它同时输出数据库服务和日志服务，这正是我们想要的。 但是它仍然需要Logging服务作为输入，这是我们不想要的。
我们可以很简单地通过输入日志记录层来满足该日志记录服务的需求，从而解决此问题。
```
val horizontalAndThenVertical: ZLayer[Any, Nothing, Database with Logging] = loggingLayer >>> (databaseLayer ++ loggingLayer)
```
我们也可以相反的顺序进行这些操作。 如果我们查看VerticallyComposed的签名，则有一个层可以输出数据库服务，并且不需要我们想要的任何其他输入，但是还不输出Logging服务。
我们可以通过将迄今为止的内容与输出日志服务的层水平组合来解决此问题：
```
val verticalAndThenHorizontal: ZLayer[Any, Nothing, Database with Logging] = (databaseLayer >>> loggingLayer) ++ loggingLayer
```
在这一点上，您可能想知道，由于我们在每个实现中都两次构建了loggingLayer，因此上述构建层的方法效率极低吗？
答案是否定的，因为默认情况下会记住图层。
这意味着，如果对某个层的引用在一个层的描述中出现了不止一次，则该层仍将仅创建一次。因此，在上面的示例中，无论我们是先垂直然后水平地组合图层还是水平地然后垂直地组合图层，dasebaseLayer和loggingLayer都将仅创建一次。
这里要注意的一件事是，为了便于记忆，基于参考身份，两层将被视为相等。
尽管这不是理想的方法，但是由于层描述了效果，因此除了依靠任意标签之外，没有其他明智的方法来确定两层是否相等，如果在多个部分中无意中使用了相同的标签，则会造成运行时错误的风险。依赖图。
要利用记忆功能，请确保始终将图层定义为val：
```
// do this
val loggingLayer: ZLayer[Any, Nothing, Logging]
// not this
def loggingLayer: ZLayer[Any, Nothing, Logging]
```
记忆化在构建依赖关系图时是一个非常好的功能，因为它使我们可以专注于依赖关系之间关系的基础逻辑，而不必担心此表示形式是否被优化。 ZLayer将为我们解决这个问题。
如果您不希望使用记忆化，则可以使用ZLayer＃fresh运算符来确保将构建该服务的单独副本。
```
val freshExample: ZLayer[Any, Nothing, Logging with Database] { loggingLayer ++ (loggingLayer.fresh >>> databaseLayer)
}
```
在这里，将向databaseLayer提供其自己的日志记录服务副本，该副本不同于提供给主应用程序的副本。
图层还有其他一些属性，这些属性使使用图层来构建依赖关系图变得很容易。
一是各层将尽可能并行获取服务。只要我们具有水平组成的图层，我们就可以并行获取这两层，前提是它们没有进一步的依赖性。
++运算符自动为我们执行此操作，因此在构造层时，我们不必显式担心并行性。我们使用++和>>>描述了各层之间的逻辑关系，ZIO将自动并行化构建各层的过程。
另一个问题是，即使面对潜在的并行获取资源和备忘录，各层也可以安全地处理资源。例如，如果有任何层与终结器相关联，例如因为它是使用ZLayer.fromAcquireRelease或ZLayer.fromManaged中的一个构造的变体，无论如何，都将运行终结器。无论提供该层成功完成，失败，被中断的效果，还是依赖关系图本身其余部分的构建过程失败或被中断，这都适用。 ZLayer还将确保在确保正确性的同时尽快运行这些终结器，为并行并行获取的资源运行终结器，并以相反的获取顺序为顺序运行的资源运行终结器。如果由于备忘而在依赖关系图的不同层之间共享一个层，则ZLayer也将正确处理该层，以确保不会过早释放资源。
所有这些使我们能够提供一种推理模式，如果我们使用ZLayer.fromAcquireRelease和ZLayer.fromManaged之类的构造函数正确描述每个服务的完成，则ZLayer将自动确保整个依赖图的完成是处理正确。