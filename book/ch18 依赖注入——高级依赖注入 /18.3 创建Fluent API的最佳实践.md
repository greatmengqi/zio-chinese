# 18.3创建Fluent API的最佳实践

因此，我们已经对结合环境类型的一些问题有了了解，并勾勒出Has如何为解决方案奠定基础。 但是，我们如何将它们放在一起以实际实现服务呢？
为了实现服务，我们建议遵循一种称为模块模式的标准模式。 这是使用模块模式的服务的典型示例：
```
  package object logging { // Module definition
    
    // 对外暴露的模块
    type Logging = Has[Logging.Service]

    object Logging {
      // 定义服务
      trait Service {
        def logLine(line: String): UIO[Unit]
      }
      // 实现服务
      val console: ZLayer[Any, Nothing, Logging] = ZLayer.succeed {
        new Service {
          def logLine(line: String): UIO[Unit] =
            UIO.effectTotal(println(line)) }
      }
    }
    
    
    // 使用服务提供的方法
    def logLine(line: String): URIO[Logging, Unit] =
      ZIO.accessM(_.get.logLine(line)) // _ 是 type logging 的占位符
    
    
    // 运行时觉得提供service的实现
    def run(): Unit ={
      logLine("test").provideLayer(logging.Logging.console) 
    }
  }
```
这个模式有几个部分，我们将在这里讨论。
首先，我们通常在其自己的名称空间中定义与服务相关的所有功能。 在这里，这就是包对象日志记录。
其次，我们将模块本身定义为`Has [Module.Service]`的类型别名。
这很关键，因为Has数据类型使我们能够无缝地组合服务。
如果您创建一个模块并且未将其定义为Has的类型别名，则可能会给您的用户带来极大的痛苦，因为您的模块将无法与其他模块组合或无法按照用户期望的方式与ZIO运算符一起使用。
第三，我们为刚刚使用对象 Logging 定义的类型别名创建“伴随对象”。
在此对象内，我们定义了Service trait，该特征定义了服务的实际接口。
在同一对象中，我们通常还提供一个实现模块实例层。例如，这里的控制台是构建简单日志记录实现的层，该记录实现将所有内容都记录到控制台。
最后，回到我们模块的整体命名空间，实现一组访问服务的方法对用户来说是非常方便的。
这些看起来像上面示例底部的logLine方法。他们只是访问环境中的模块并在服务上调用相应的方法。
因为环境访问器仅在服务上调用相应的方法，所以这些访问器实际上并未实现新功能。但是，它们可以为您的用户带来更好的体验。

考虑以下两个片段：
```
  for {
    _ <- logging.logLine("Doing something")
    _ <- logging.logLine("Doing something else")
    _ <- logging.logLine("Doing a third thing")
  } yield ()
  
  for {
    _ <- ZIO.accessM[Logging](_.get.logLine("Doing something"))
    _ <- ZIO.accessM[Logging](_.get.logLine("Doing something else"))
    _ <- ZIO.accessM[Logging](_.get.logLine("Doing a third thing"))
  } yield ()
```
大多数人会认为，第一个比第二个要好得多。一方面，第一个示例中的每一行都更加简洁。但是除此之外，第一个示例更具声明性，着重于我们想要完成的事情，而不是我们想要如何做。
在第一个示例中，所有用户只需关心的是环境中是否存在此Logging服务，然后可以通过调用logging.logLine进行记录来使用它。用户只需要知道您的服务提供了他们可以使用的这些方法以及在何处可以找到要在其应用程序顶部最终提供的实现的方法，用户就不需要了解很多其他信息。
在第二个示例中，用户必须使用accessM自己访问服务。然后，他们必须在Has上调用get方法，以从Has数据类型中检索要使用的服务，这可能需要了解Has及其实现。
我们希望为用户提供最佳的API，因此我们建议使用模块模式并在可能的情况下提供环境访问器。
这需要服务的实现者做更多的工作，但是为用户提供了更好的体验。如果您想避免自己编写环境访问器，甚至可以使用ZIO Macros中的@accessible注释为您完成此操作。