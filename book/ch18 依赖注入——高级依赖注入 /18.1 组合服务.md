# 18.1 组合服务
在上一章中，我们将服务描述为描述某些功能的接口。 例如，我们可能有一个具有简化接口的数据库服务和日志记录服务，如下所示：
```
trait Database {
    def getUserName(id: Long): UIO[String]
}
trait Logging {
    def logLine(line: String): UIO[Unit]
}
```
我们还说过，将需要不同服务的两个效果组合在一起的结果是需要两个服务的新效果，这里两个都表示为交集类型。
```
  val databaseEffect: ZIO[Database, Nothing, String] = ???
  val loggingEffect: ZIO[Logging, Nothing, Unit] = ???
  
  val combinedEffect: ZIO[Database with Logging, Nothing, String] =
    databaseEffect <* loggingEffect
```
这是非常合乎逻辑的，代表了这样一个概念：如果我们的效果的一部分需要数据库服务的功能，而我们的效果的一部分需要日志服务的功能，那么要运行我们的效果，我们需要同时提供数据库服务和功能的东西 和日志记录服务。 但是，如何实际使用日志创建数据库？
理想情况下，如果我们已经拥有数据库服务和日志记录服务，我们希望能够将它们与简单的运算符结合在一起：
```
  val databaseService: Database = ???
  val loggingService: Logging = ???
  val combinedService: Database with Logging =
    databaseService ++ loggingService // does not compile
```
不幸的是，这行不通。 数据库和日志记录只是特征，没有像++这样的方法可以通用地组合特征。
我们希望能够实现这样的方法：
```
def mix[A, B](a: A, b: B): A with B = ???
```
从概念上讲，如果我们具有类型A的值和类型B的值，则应该能够通过对A上定义的方法进行任何调用并将它们委托给A值并对所定义的方法进行任何调用来实现B的类型A。 在B上并将其委托给B值。
但是没有一种方法可以在不使用宏的情况下在Scala中表达。
结果，如果我们将服务简单定义为这样的接口以实现组合服务，则需要扩展每个服务并手动重新实现其每个方法：
```
  val combinedService: Database with Logging = new Database with Logging {
    def getUserName(id: Long): UIO[String] = databaseService.getUserName(id)
    def logLine(line: String): UIO[Unit] = loggingService.logLine(line)
  }
```
我们只是在使用混合方法进行上面概念性描述的操作，但是可以看到，这种感觉已经开始像样板了。
这是当我们只有两个服务，每个服务实现一个方法时。 想象一下，如果我们有很多服务，每个服务实现许多方法，那么会有多少样板。
我们可以通过定义每个包含服务的模块来稍微清理一下。
```
  trait Database {
    def database: Service
    trait Service {
      def getUserName(id: Long): UIO[String]
    }
  }
  trait Logging {
    def logging: Service
    trait Service {
      def logLine(line: String): UIO[Unit]
    }
  }
```
现在，我们可以通过实现两个模块的服务来组成模块：
```
  val databaseModule: Database =
    ???
  val loggingModule: Logging =
    ???
  val combinedModule: Database with Logging = new Database with Logging {
    val database: Database.Service = databaseModule.database
    val logging: Logging.Service = loggingModule.logging
  }
```
这样做的好处是，我们在组成模块时只需要重新实现每个服务，而不是每个服务方法。 但是这里仍然有很多样板，尤其是当我们使用大量服务时。
这里还有一个更根本的问题。
如果我们要结合两个具体的服务（例如数据库和
正在记录。 但是，如果其中一项服务是抽象的，那是行不通的。
例如，如果我们有一个Logging服务和其他一些服务R，我们想说我们可以用R创建Logging类型的服务。但是我们不能这样做：
```
def enrichWithLogging[R](r: R, logging: Logging): R with Logging = 
new R with Logging { ??? }
// does not compile

```
由于几个原因，这无法正常工作。
首先，由于R是完全抽象的，所以Scala编译器不知道是否可以
扩展了。 例如，R可能是 sealed trait 或  final case class 类。 其次，由于R是完全抽象的，我们不知道定义了哪些方法
因此，我们无法使用Logging在R中实现这些方法。
无法实现这样的方法是一个重大问题，因为我们希望能够部分提供环境。 例如，我们希望能够实现一种需要日志记录服务和某些其他服务集的效果，而只是消除对日志记录服务的依赖性。
```
def provideLogging[R, E, A](zio: ZIO[R with Logging, E, A])(logging: Logging): ZIO[R, E, A] ???
```
但是我们无法实现这一点，因为我们需要使用ProvideSome并在Logging中提供一个函数`R => R with Logging`。 但是我们只是说不可能一般地实现这样的功能。