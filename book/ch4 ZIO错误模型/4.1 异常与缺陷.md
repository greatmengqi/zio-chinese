[0.目录](../0.目录.md)
# 4.1 异常与缺陷
ZIO错误类型使我们可以通过查看类型签名来查看effect失效的所有方式。但是有时，故障可能以一种不应该发生的方式发生。
例如，采用以下代码片段：
```
  import zio._
  val divisionByZero: UIO[Int] =
    UIO.effectTotal(1 / 0)
  // divisionByZero: UIO[Int] = zio.ZIO$EffectTotal@683aef7f
```

我们在这里使用了effectTotal构造函数，这意味着返回类型为UIO，表明效果不会失败。但是在JVM上，除以零将引发ArithmeticException。如何处理此故障？
答案是ZIO区分了两种类型的故障： •
* 错误。错误是用effect的错误类型表示的潜在故障。他们对预期和潜在可恢复的故障方案进行建模。从字符串解析整数时，NumberFormatException是错误的示例。我们知道解析可能会失败，因为字符串可能不是有效的整数，并且我们可以采用多种方法进行恢复（例如，使用默认值，解析另一个整数，将失败传播到更高级别的应用程序等）。这些有时称为类型错误或检查失败。
* 缺陷。缺陷是未在effect的错误类型中表示的潜在故障。他们为无法预料或无法恢复的故障场景建模。例如，在控制台程序中，从控制台读取的IOException可能是缺陷。我们的控制台程序基于与用户的控制台交互，因此，即使我们甚至无法从控制台读取信息，除了放弃该程序外，我们无能为力。这些也称为fiber故障，无类型故障或未检查故障。

将某种类型的故障视为错误还是缺陷可能涉及一些判断。相同类型的故障可能是一个应用程序中的错误，而另一个应用程序中的缺陷。确实，同一类型的错误可能是在一个应用程序级别的失败，而在另一应用程序是更高级别的缺陷。
对于前者的示例，在控制台应用程序中，可能无法从IOException中恢复，因此将其视为缺陷可能是有意义的。但是在允许用户输入控制台输入以自定义报告生成设置的应用程序中，将其视为错误并通过使用默认设置生成报告来处理它是有意义的。
对于后者的示例，连接到数据库失败可能被认为是低级代码中的错误，因为也许我们可以通过重试连接或使用备份数据库来进行某种恢复。但是在更高级别上，无法连接到任何数据库的应用程序最终将中止。
其他一些effect类型以及Scala自己的Future之类的异步数据类型，将错误类型严格固定为Throwable，因为任何程序都可能因Throwable失败。这不仅降低了灵活性，还因为无法描述无法失败或因业务错误而失败的后果，而且模糊了失败与缺陷之间的区别。

如果我们计划今晚与朋友见面吃晚饭，我们可能会告诉我们的朋友我们是否陷入了可能迟到的工作会议。但是，对我们的朋友说我们可能会被闪电击中，或者在我们开车去见朋友时可能发生地震，对我们来说真的没有任何意义。
交流有关可能可以弥补的预期故障的信息将很有帮助。也许我们的朋友可以等到餐厅发短信，直到我们发短信说我们要下班了？但是，始终交流每种可能的故障模式都没有帮助。我们的朋友应该做些什么，因为我们可能会被闪电击中？
同样，当然，任何程序都可能由于灾难性错误而失败。例如，如果我们将苏打水洒在笔记本电脑上。但是这些信息通常不会帮助我们的同事或用户对我们的代码做任何不同的事情。失败表示我们的程序可能失败的预期方式，可以解决。其他所有内容均被视为缺陷。


