# 22.2 使用ZIO重试和重复
解决此问题的方法是ZIO的Schedule数据类型。 时间表是对重试或重复某项策略的描述。
```
trait Schedule[-Env, -In, +Out]
```
Schedule需要环境Env，使用类型In的值来确定是继续执行还是延迟执行，并生成类型Out的摘要值。
Env类型参数允许日程表在环境中潜在地使用某些服务来决定是继续执行还是延迟执行。

例如，某个计划在指定时间间隔内随机延迟一段时间，那他就需要一个Env类型叫做Random，以反映该时间表对随机性来源的依赖性。 如果Schedule不依赖于任何其他服务（通常是这样），则Env类型将为Any。
In类型参数表示计划表每次决定是继续执行某个延迟还是要执行时都要考虑的输入。在重试的情况下，In类型将表示重试策略处理的错误的类型。
例如，仅对Throwable的某些子类型继续执行并立即对Throwable的其他子类型立刻结束，那他就有一个Throwable的In类型。如果日程表不依赖于特定的输入，例如，日程表总是重复指定的次数，则In类型将为Any（代表无聊发送什么事情，都要重新执行）。
Out类型参数表示一些摘要值，用于描述计划的状态。重试调度器时，不直接使用Out类型参数，组合调度器时很有用
Out参数的确切类型将根据特定的计划而有所不同，例如，重复指定次数的计划可能会输出到目前为止的重复次数。某些计划可能只是简单地返回其输入不变，在这种情况下，In的类型将与Out的类型相同。
使用Schedule，可以非常简单地解决我们执行重试策略的原始问题，该策略重试指定的次数并在每次重试之间保持恒定的延迟。
```
def delayN(n: Int)(delay: Duration): Schedule[Any, Any, (Long, Long)] = Schedule.recurs(n) && Schedule.spaced(delay)
```
就像我们想要的那样，我们能够从两个更简单的时间表构建此时间表，这些时间表分别描述了要重复多少次以及两次重复之间需要延迟多长时间的概念。
重复计划仅与重复次数有关。它连续执行指定的次数，每一步之间没有延迟。间隔的计划表专门考虑重复之间的延迟。它以每一步之间的指定延迟永远持续下去。&&运算符组合两个时间表以产生一个新的时间表，该时间表仅在两个时间表都希望继续的情况下才继续使用每个步骤的最大延迟。
因此，合并的计划将继续执行五次，因为在此之后，重复计划将不希望继续执行，并且仅当两个计划都希望继续执行时，组合计划才继续执行。并且在每个步骤中，它都会延迟指定的持续时间延迟，因为recurs的延迟为零，并且组合时间表始终使用最大延迟。
这使我们以一种极其可组合的方式实现了所需的行为，以至于我们通常甚至不定义专门的构造函数，而是直接使用现有的构造函数和运算符创建时间表。
```
val schedule = Schedule.recurs(5) && Schedule.spaced(1.second)
```
在本章的其余部分中，我们将看到更多的调度程序构造函数和运算符，但这应该使您了解使用Schedule的强大功能和优雅之处。
由于Schedule仅描述了重试或重复某项内容的策略，因此我们需要一种方式来获取此描述并将其应用于重试或重复特定效果。 最常见的方法是ZIO上的重试和重复运算符。
```
  trait ZIO[-R, +E, +A] {
    def repeat[R1 <: R, B](schedule: Schedule[R1, A, B]): ZIO[R1, E, B]
    def retry[R1 <: R, S](schedule: Schedule[R1, E, S]): ZIO[R1, E, A]
  }
```
重试运算符采用一个Schedule，该Schedule能够处理该效果可能导致失败的所有错误，并返回一个新效果，该效果要么以原始值成功要么因原始错误而失败。
这里要注意的一件事是，尽管Schedule产生类型为S的输出，但是由于我们返回的最终结果要么以E失败，要么以A成功，所以最终将丢弃该结果。如果您想对的输出执行进一步的逻辑Schedule中有retryOrElse和retryOrElseEither变体，它们允许指定一个后备函数，如果在所有重试后效果仍然失败，并且可以访问最终错误和时间表的输出，则将调用后备函数。
重复运算符类似于重试运算符，但允许使用时间表来描述如何重复成功的效果。例如，我们可能重复执行“时间表”来描述每个星期一早上指定时间生成报告。
重试效果需要一个能够处理该效果可能会失败的所有错误的时间表，而重复效果需要一个能够处理该效果可能会成功的所有值的时间表。这使时间表可以根据效果产生的值来决定是否重复，例如重复直到满足谓词。
附表输出的值将重复生效。时间表通常具有相同的输入和输出类型，因此重复效果将具有与原始效果相同的结果类型。