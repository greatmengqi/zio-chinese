# 22.1传统重试运算符的局限性
对于我们来说，处理可能因某种原因而失败的效果非常普遍。 例如，由于各种原因，从Web服务获取数据可能会失败，包括：
* 我们没有网络连接•服务不可用
* 我们受到速率限制
* 我们没有许可
在这些情况下，如果效果失败，我们通常想重试该效果。 我们的重试策略通常包括：
1. 我们要重试多少次？
2. 根据发生的故障类型应如何进行更改？
通常，我们希望重试之间有一些延迟，因为我们希望在重试之前留出时间来处理可能导致故障发生更改的情况。

如果没有网络连接，则如果我们立即重试，则不太可能建立连接，但是如果我们在一秒钟，一分钟或一小时内重试，则可能会建立连接。
我们还经常希望我们的重试策略依赖于发生的错误，因为不同的错误可能需要不同的重试策略。 如果我们受到速率限制，那么我们需要等待重试，直到重设速率限制为止；而如果我们没有权限，那么在我们手动解决问题之前，根本没有必要进行重试。
我们可以尝试使用现有的错误处理运算符以及在ZIO上下文中使用递归的能力来实施重试策略。 例如，这是我们可以实现一个运算符，该运算符重试指定次数的效果，每次重试之间具有恒定的延迟：

```
  def retryWithDelayN[R, E, A](n: Int)(zio: ZIO[R, E, A])(duration: Duration): ZIO[R with Clock] =
    if (n <= 0)
      zio
    else
      zio.catchAll(_ => retryWithDelayN(n - 1)(zio)(duration).delay(duration))
```
如果剩余的重试次数n小于或等于零，那么我们只需执行效果即可。否则，我们将执行效果，如果失败，则以指定的延迟和更少的剩余重试次数再次调用retryWithDelayN。
一方面，该代码相对有吸引力。它使用catchAll错误处理运算符和递归来非常简洁地实现我们的重试策略，并有力保证它不会阻塞任何线程并且可以安全地中断。
与使用Future相比，这已经是一个巨大的进步，因为我们可以重试ZIO效果，这是对并发程序的描述，而我们不能重试已经“在运行中”的Future。此外，Future不可中断，并且没有内置的方式来计划要在指定的持续时间后运行的操作。
但是，这种解决方案并不完全令人满意。问题在于它是不可组合的，因此我们每次都必须从头开始实施新的重试策略，而不是能够以更简单的方式实施更复杂的重试策略。
要看到这一点，请考虑如果我们想重试指定的次数并在每次重试之间保持恒定的延迟，但是只要错误满足谓词，该怎么办。
从概念上讲，似乎我们应该能够按照现有的重试指定次数的方式来实现此目的，并且每次重试之间都有恒定的延迟。毕竟，除了附加条件外，它们完全相同，因此我们应该能够以某种方式将“现有”实现与新条件“结合”以实现此重试策略。
不幸的是，这是不可能的。
retryWithDelayN运算符只是一种方法，因此我们无法“深入了解”其实现，只能重试某些错误。此外，一旦将运算符应用于ZIO效果，我们将获得另一个ZIO效果，因此我们无法修改已应用的重试策略。
当然，我们可以实施一个新的变体，该变体也需要一个谓词来确定是否重试。但这只是在重述问题，因为每次我们要实施新的重试策略时，都需要从头开始实施。
我们可以想象各种各样的重试策略。例如，对于指定的重试次数，重试可能应以恒定的间隔进行，然后在此之后以指数级增加的延迟达到最大数量，但仅限于某些类型的错误。
我们需要的是一种定义重试策略的方法，其中每个重试策略都是一个“构建块”，并且我们可以将更简单的重试策略粘合在一起以制作更复杂的重试策略，就像我们可以从一个程序构建非常复杂的ZIO程序一样。
简单运算符的数量相对较少。
从这个角度来看，我们可以看到，即使是使用retryWithDelayN实施的原始重试策略实际上也混合了两个方面，即重试次数和重试之间的延迟时间。理想情况下，我们希望能够将其定义为两个重试策略的组合，每个重试策略专门处理这些问题之一。
我们如何实际定义重试策略，以便我们可以以这种方式组合它们？