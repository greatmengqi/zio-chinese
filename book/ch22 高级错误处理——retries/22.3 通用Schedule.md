# 22.3 通用Schedule
现在，我们已经对Schedule有了基本的了解，下面我们来关注不同的Schedule构造函数。
这些构造函数构成了Schedule的基本“构建块”。 在接下来的两节中，我们将学习变换和组合这些方法的不同方法构建块，因此到最后，您将可以建立复杂的时间表来解决自己的业务问题。
## 22.3.1 递归调度
一个简单的Schedule构造函数族仅描述重复指定次数。
这里最有用的构造函数是recurs，它创建一个计划，该计划重复指定的次数，并且两次重复之间没有延迟。
```
  object Schedule {
    def recurs(n: Long): Schedule[Any, Any, Long] =
      ???
  }
```
通常，我们还会希望在用于重复或重试效果的最终计划中有一些延迟，但是通过将 recurs 与另一个描述延迟的构造函数结合使用，我们可以创建可以重复有限次数的计划，每次重复之间都有一个延迟。 还有一个 once 的构造函数，它创建一个连续无间断地执行时间表的计划，而一个 stop 构造函数创建了一个立即完成的时间表。

##  22.3.2 延迟调度
我们将讨论的Schedule构造函数的第二系列描述了两次重复之间的延迟模式。
通常，对于模块化，这些计划将描述无限重复的模式，它们之间存在一些延迟。 这使我们能够将它们与其他计划组合在一起，从而限制了重复次数，如我们在上文中所见，可以精确地定义所需的计划。
这些构造函数中最简单的是间隔的构造函数。
```

object Schedule {
    def spaced(duration: Duration): Schedule[Any, Any, Long] = ??? 
}
```
此计划仅延迟每个步骤之间的指定持续时间，并输出到目前为止的重复次数。 这等效于每次重复在ZIO上调用延迟运算符。
fixed 构造函数是这个构造函数一个稍微复杂的变体。
```
  object Schedule {
    def fixed(interval: Duration): Schedule[Any, Any, Long] =
      ???
  }
```
fixed构造函数类似于间隔结构，它基于恒定的延迟生成调度，并输出到目前为止的重复次数。区别在于重试或重复执行效果所花费的时间是如何计算延迟的因素。使用间隔时间安排，每次重复执行之间都会始终施加相同的延迟，而不管重复执行或重试效果需要花费多长时间。
例如，假设我们要重复一个效果，该效果需要用spaced(10.seconds)）构造的时间表才能执行。在这种情况下，效果将运行一秒钟，然后将再出现十秒钟的延迟，然后效果将运行一秒钟，然后再出现十秒钟的延迟，依此类推。

这意味着重复之间总是存在恒定的延迟，但是实际的重复频率可能会有所不同。例如，在上述情况下，每次重复之间有10秒的延迟，但是由于效果需要一秒钟才能执行，因此效果实际上仅每11秒执行一次。相反，在fixed的时间表下，效果开始执行的时间间隔，这意味着实际延迟可能有所不同。如果效果需要一秒钟执行，而我们使用fixed(10.seconds)构建的时间表对其进行重试，则效果将运行一秒钟，然后我们将延迟九秒钟，然后效果将再运行一秒钟，然后我们将延迟九秒钟，依此类推。

这意味着重复或重试的效果总是以固定的间隔重复出现，但是效果之间的实际延迟可能会根据效果执行的时间而有所不同。 在上述情况下，每次重复之间只有九秒的延迟，但是效果将每十秒钟执行一次。固定的进度表还内置了逻辑，以防止计划的效果“堆积”。 因此，如果重试效果花了20秒钟才能执行下一次重复操作，但该效果只会在该重复执行一次，而不是执行两次。通常，如果要在两次重复之间保持恒定的延迟，请使用spaced。 如果您想要固定的重复频率，请使用fixed。使用恒定延迟的调度构造函数的另一种形式是窗口构造函数。
```
  object Schedule {
    def windowed(interval: Duration): Schedule[Any, Any, Long] =
      ???
  }
```
这将创建一个计划，该计划将延迟到最接近的“窗口边界”，并返回到目前为止的重复次数。
例如，如果使用`windowed（10.seconds）`构造函数构造了时间表，并且效果需要一秒钟执行，则该时间表将延迟9秒，因此在下一个10秒“窗口”开始时再次评估效果。
在这方面，window时间表类似于我们刚刚看到的fixed时间表。当效果执行时间长于窗口间隔时，窗口化时间表与行为不同。
在固定的时间表下，我们看到，如果执行效果的时间比固定间隔长，那么下一次重复将立即发生而不会延迟。例如，如果固定间隔为十秒，并且效果需要十一秒才能执行，则时间表将立即重现，并在十一秒后开始重新评估效果。
相比之下，加窗口的时间表将始终等到下一个窗口的开始。因此，如果窗口长十秒钟，并且效果花了11秒钟执行，则时间表将延迟9秒，以在下一个十秒窗口的开头再次开始评估效果。
当您想要以指定的间隔执行效果时，并且如果效果花费的时间比间隔长，请等到下一个间隔，窗口运算符就很有用。
从这里继续，我们有各种构造函数来创建时间表，其中延迟不是恒定的，而是以某种方式变化。这些构造函数中的每个构造函数都返回一个计划表，该计划表输出最近的延迟。
其中第一个是线性构造函数。
```
  object Schedule {
    def linear(base: Duration): Schedule[Any, Any, Duration] =
      ???
  }
```
这将构建一个计划，该计划将每个重复之间的间隔像间隔一样延迟，但是现在延迟的持续时间从基值开始线性增加。 例如，`linear（1.second）`将构造一个具有一秒延迟，然后两秒延迟，三秒延迟等的调度。
线性计划会随着计划的进行而增加重复之间的延迟，因此，当您最初想频繁重试效果，然后在仍然失败时想要减少重试次数时，线性计划会很有用。 例如，如果由于没有连接而导致对Web服务的请求失败，则在出现暂时性问题的情况下，我们可能希望首先进行快速重试，但是如果连接仍然不可用，则应重新尝试慢一些。
此主题的另一个变体是 指数 构造函数。
```
  object Schedule {
    def exponential(base: Duration, factor: Double = 2.0): Schedule[Any, Any, Duration] =
      ???
  }
```
这将创建一个计划，随着计划像线性计划一样继续进行，将增加重复之间的延迟，但是现在，该延迟将呈指数形式而不是线性地增加。因此，例如，使用`exponential（1.second）`构造的计划最初将延迟1秒，然后延迟2秒，然后延迟4秒，依此类推。
指数计划表为指数补偿策略建模，并且比线性策略快得多地增加了后续重复之间的延迟。面对不确定性将持续多长时间的不确定性，指数补偿策略可能是一个很好的策略，因为随着我们对条件持续多久的最佳估计，它增加了重试之间的时间。
如果要更改指数增长因子，可以通过为因子参数指定自己的值来进行。例如，使用`exponential（1.second，3.0）`构造的计划最初将延迟一秒钟，然后延迟三秒钟，然后延迟九秒钟，依此类推。
斐波那契构造函数描述了另一种增加后续重复之间的延迟的策略，这次基于斐波那契数列，其中每个延迟是两个先前延迟的总和。
```
  object Schedule {
    def fibonacci(one: Duration): Schedule[Any, Any, Duration] =
      ???
  }
```
使用此计划，前两个延迟将持续指定的持续时间，然后每个后续延迟将是前两个延迟的总和。 因此，例如，使用fibonacci（1.second）构造的调度将延迟一秒钟，一秒钟，两秒钟，三秒钟，五秒钟，八秒钟等。
带有进度表的其余构造函数允许从自定义序列创建有限的进度表，而不是从现有数学序列中创建无限的进度表。
其中最简单的是fromDuration构造函数，它创建一个计划，该计划以指定的延迟重复一次。
```
object Schedule {
    def fromDuration(duration: Duration): Schedule[Any, Any, Duration] =???
}
```
这是一个非常简单的进度表，因此我们很少希望将此进度表用作问题的整体解决方案，但是它可以作为修改现有进度表以适应我们的业务需求的有用工具。
稍微复杂一点的变体是fromDurations构造函数
```
  object Schedule {
    def fromDurations(duration: Duration, durations: Duration*): Schedule[Any, Any, Duration] = ???
  }
```
这允许创建一个计划，该计划针对每个指定的持续时间重复一次，每次都有相应的延迟。 计划输出最后一次重复的持续时间。 当您要使用的特定延迟系列不能完全适合ZIO支持的现有数学系列之一时，此构造函数可能非常有用。
##  22.3.3 条件Schedules
我们将讨论的调度程序构造函数的第三类允许表达条件性的概念。
这些计划检查计划的输入，并根据输入是否满足谓词来决定是否继续。 这些构造函数有很多变体，但从概念上讲它们都很相似。
```
  object Schedule {
    def recurWhile[A](f: A => Boolean): Schedule[Any, A, A] =
      ???
    def recurWhileM[Env, A](f: A => URIO[Env, Boolean]): Schedule[Env, A, A] =
      ???
    def recurWhileEquals[A](a: => A): Schedule[Any, A, A] =
      ???
    def recurUntil[A](f: A => Boolean): Schedule[Any, A, A] =
      ???
    def recurUntilM[Env, A](f: A => URIO[Env, Boolean]): Schedule[Env, A, A] =
      ???
    def recurUntilEquals[A](a: => A): Schedule[Any, A, A] =
      ???
  }
```
recurWhile构造函数代表此计划构造器系列。 它构造了一个调度表，只要指定谓词为true，便会立即重复执行，而不会延迟，但是一旦谓词为false，它就会立即执行。
还有一个recurWhileM变体，允许在确定是否应继续执行计划的过程中执行某种效果，以及简化的recurWhileEquals构造函数，只要输入等于指定值，该构造函数就可以继续执行。
这些构造函数中的每个构造函数还具有一个对应的recurUntil变体，只要指定的谓词为false，该变体就会永远持续下去，并且在指定的条件评估为true时立即完成。
这些构造函数使我们可以开始表达一种想法，即我们希望时间表是否继续取决于输入类型。 例如，我们可以使用这些构造函数来表达这样的思想：仅应重试网络连接错误，或者应重复尝试找到解决方案，直到解决方案满足某些参数为止。

##  22.3.4 输出 Schedules
调度程序构造器的下一个系列将创建调度程序，以通过某种方式输出有用的值，方法是将现有输入转换为输出，或者从调度程序本身生成新的输出，例如，从调度程序的第一步到现在已经经过了多少时间。
用于将输入转换为输出的最基本的计划构造器是fromFunction，它从函数创建计划。
```
  object Schedule {
    def fromFunction[A, B](f: A => B): Schedule[Any, A, B] =
      ???
  }
```
fromFunction返回的调度总是无延迟地重复执行，并使用指定的函数f将接收到的每个A输入简单地转换为B输出。
identity构造函数是一种变体，类似于fromFunction，但是构造了一个日程表，该日程表将其输入通过不变的方式传递，而不是通过函数进行转换。
```
  object Schedule {
    def identity[A]: Schedule[Any, A, A] =
      fromFunction(a => a)
  }
```
当与其他构造函数组合以创建更复杂的计划（这些计划仍返回其原始输入）时，identity造函数可能特别有用。 然后，这些时间表可以与ZIO上的retry运算符一起使用，以返回添加了重试逻辑的效果，这些效果仍然可以成功执行与原始效果相同的值类型。
identity构造函数的另一种变体是collectAll。
```
  object Schedule {
    def collectAll[A]: Schedule[Any, A, Chunk[A]] =
      ???
  }
```
collectAll构造函数就像通过遍历A值的identity一样，包含到目前为止输入的所有A值并输出所有这些值的数据结构时。
例如，如果我们有一个使用`collectAll [Int]`构造的调度，并且它接收到1、2和3的输入，则它将输出Chunk（1），Chunk（1、2）和Chunk（1、2、3） ，每次输出到目前为止收到的所有输入。
这对于收集评估进度表中产生的所有中间输出很有用。例如，如果我们重复一个效果，直到它对某个问题达成满意的解决方案，则可以使用collectAll可视化在生成最终解决方案的过程中生成的所有中间解决方案。
除了基本的collectAll构造函数外，还有collectWhile和collectUntil变体，只要满足某些谓词，它们就可以继续。您可以将它们视为我们上面在collectAll计划中看到的recurWhile和recurUntil计划的组成。
上面的构造函数是创建计划的主要方法，这些计划以某种方式将输入转换为输出。除了这些之外，还有一组构造函数可以创建计划表，以输出某些值，而不管收到的输入如何。
其中最通用的一种是 unfold 构造器，它允许通过将函数重复应用于初始值来构造时间表。
```
  object Schedule {
    def unfold[A](a: => A)(f: A => A): Schedule[Any, Any, A] =
      ???
  }
```
 unfold 返回的调度器将首先输出指定的值，然后在每次重复执行之后，将函数f应用于最后一个值以生成新展开值。
例如，我们可以实现另一个构造函数count，它只使用unfold输出到目前为止的重复次数。
```
object Schedule {
    val count: Schedule[Any, Any, Long] = unfold(0L)(_ + 1L) 
}
```
我们可以通过unfold实现的另一个甚至更简单的构造函数是succeed，它仅返回始终输出相同常数值的调度。
```
  object Schedule {
    def succeed[A](a: => A): Schedule[Any, Any, A] =
      unfold(a)(a => a)
  }
```
最后一个特别有用的变体是 elapsed 构造函数，该构造函数返回一个新的计划，该计划始终重复执行，没有任何延迟，但是输出从第一步开始的时间。
```
  object Schedule {
    val elapsed: Schedule[Any, Any, Duration] =
      ???
  }
```
我们可以使用它来查看每次计划重现时经过了多少时间，或者在经过一定时间后与其他操作员一起停止。

## 22.3.5 固定时间点调度器
时间表构造器的最后一个重要系列是那些在固定时间点重复出现的时间表。
到目前为止，我们的大多数讨论都集中在以某些相对时间间隔重现的计划，例如，两次重现之间有一分钟的延迟。
但是，我们也可以使用时间表来描述在固定的绝对时间点（例如，每个星期一的上午9点）发生的复发模式。这使我们能够使用时间表以一种非常原则化和可组合的方式来实现类似 “ cron job”的功能。
ZIO对此功能的支持始于几个基本的构造函数，用于描述各个绝对时间点的重复发生。就像我们将看到的那样，它们中的每一个都是非常具体的，并且它们中的每一个都不一定特别有用，但是它们以正确的方式组合在一起，以描述绝对时间点上任何可能的重复序列。
在本节中，我们将重点介绍这些构造函数，稍后将看到如何开始将它们组合起来以构建可解决更为复杂的“现实世界”问题的时间表。
用于处理绝对时间点的基本构造函数是：
```
  object Schedule {
    def secondOfMinute(second: Int): Schedule[Any, Any, Long] =
      ???
    def minuteOfHour(minute: Int): Schedule[Any, Any, Long] =
      ???
    def hourOfDay(hour: Int): Schedule[Any, Any, Long] =
      ???
    def dayOfWeek(day: Int): Schedule[Any, Any, Long] =
      ???
  }
```
这些构造函数中的每个构造函数都会返回一个计划，该计划始终重复发生并延迟每次重复，直到下一个满足指定条件的绝对时间点为止，并返回到目前为止的重复次数。 例如，使用secondOfMinute（42）构造的时间表将在12：00：42、12：01：42、12：02：42等重复出现，依此类推，而使用minuteOfHour（42）构造的时间表将在12 ：42：00、1：42：00、2：42：00，依此类推。
通常，我们不只是希望每个小时或每天重复一次，而是要结合这些时间的某种组合，例如每个星期一的上午9点。 我们将在本章的后面看到更多有关它如何工作的信息，但是就像我们可以为相对延迟组合时间表一样，我们也可以为固定时间点组合时间表一样。
最有用的方法之一是&&运算符，它描述两个计划的重复间隔的交集。 例如，这是我们可以描述每个星期一上午9点做某事的方式。
```
val automatedReportSchedule = Schedule.dayOfWeek(1) && Schedule.hourOfDay(9)
```
再次，我们将在本章的后面看到更多有关如何编写时间表的信息，但是希望这使您了解如何使用这些看似非常简单的构造函数来描述更复杂的模式，以便在固定的时间点重复执行。