# 17.3 ZIO就是一个Reader Monad
ZIO的依赖项注入方法始于采用 Reader monad的想法，并将其直接烘焙到ZIO数据类型中。 这意味着访问和环境方法可直接在ZIO上使用，并且不需要其他数据类型。
```
trait ZIO[-R, +E, +A] {
    def provide(r: R): IO[E, A]
}
object ZIO {
    def environment[R]: ZIO[R, Nothing, R]
}

```
这对上述方法有几个好处。
由于ZIO直接提供了这些运算符，因此我们不再需要使用任何其他数据类型，并且可以直接访问我们正在学习的ZIO上的所有运算符。 由于我们没有使用其他数据类型，因此性能也更好。
因为这里没有使用更高种类的类型，类型类或隐式函数，所以大大降低了代码复杂度。
也许最重要的是，我们能够以一种我们没有使用其他任何方法的方式对服务进行抽象。 如果我们的效果取决于Clock，Console和Random服务，则可以为此创建一个类型别名：
```
type MyEnv = Clock with Console with Random
```
然后，我们可以在先前列出所有三个服务的任何地方使用该类型别名。
```
def effect1: ZIO[Clock with Console with Random, Nothing, Unit] = ???
def effect2: ZIO[MyEnv, Nothing, Unit] = effect1
// works
```
在这个小示例中，这已经是一个很好的简化，但是您可以想象，在具有许多依赖关系的大型应用程序中，这可以为我们节省多少样板
```
type Env = Logging with Database with Redis with Cassandra with Kafka with Persistence with
```
通过该介绍，让我们开始探讨如何在自己的应用程序中使用环境类型。 从根本上讲，我们需要对环境做两件事：
1.Access 环境中的服务以使用自己的代码对它们进行处理，例如访问日志记录服务，以便我们可以记录行。
2.Provide 所需的环境效果，例如实时数据库实现，以便我们可以实际运行它。
在接下来的两节中，我们将依次讨论每一个。
