# 17.2 传统依赖注入的局限性
有几种解决此问题的传统方法，但是它们都有很大的局限性。

## 17.2.1 Tagless Final
处理依赖项注入问题的第一种传统方法是所谓的 tagless final 风格。 在这种样式中，依赖关系被建模为隐式功能。
```
trait Logging[F[_]] {
    def logLine(line: String): F[Unit]
}

trait Database[F[_]]

trait Application {
    def run[F[_]: Logging : Database]: F[Unit]
}
```
上面的语法是上下文绑定，类似于：
```
def run[F[_]](implicit logging: Logging[F], database: Database[F]): F[Unit]
```
这从本质上说F是某种隐式`Logging [F]`
和`Database [F]`可用的效果类型。
然后，我们可以将服务传递到应用程序的较低级别，只需添加
这些服务在上下文范围内沿途进行方法调用。
```
def foo[F[_]: Logging : Database]: F[Unit] 
def run[F[_]]: Logging : Database]: F[Unit] = foo
```
为了实际运行我们的程序，我们需要为某些具体类型`F [_]`提供Logging和Database的实例。 例如，如果我们将`F [_]`专用于UIO，则会得到：
```
  trait Logging {
    def logLine(line: String): F[Unit]
  }
  object Logging {
    implicit val UIOLogging: Logging[UIO] = new Logging[UIO] {
      def logLine(line: String): UIO[Unit] = ???
    }
  }
```
然后，我们可以通过调用`run [UIO]`来运行程序。
在讨论这种方法的局限性之前，让我们先谈谈它的优点。
它的确使我们能够对应用程序各部分的依赖关系进行显式建模。 我们的整个应用程序具有以下特征：
```
def run[F[_]: Logging : Database]: F[Unit] = ???
```
这表明我们的整个应用程序同时需要日志服务和数据库服务。
我们的应用程序的可能具有以下特征：
```
    def bar[F[_]: Logging]: F[Unit] = ???
```
这表明应用程序的这一部分仅需要日志服务，而无需数据库服务。
这种方法还使我们能够表达一种想法，即当我们将需要不同服务的程序的两个部分合并时，合并后的程序既需要第一部分所需的服务，也需要第二部分所需的服务。
```
  def baz[F[_]: Database]: F[Unit]
  def combined[F[_]: Logging: Database]: F[Unit] = {
    bar
    baz
  }
```
这里bar需要一个隐式Logging服务在范围内，而baz需要一个隐式Database服务在范围内，因此Scala编译器将要求我们通过组合使用Logging服务和Database Service来向上传播这种依赖关系。
因此，tagless final 风格肯定可以解决某些问题。 它在缺陷是什么呢？
首先，这种编程风格导致代码风格大大复杂。
为了简洁起见，我们已经掩盖了大部分复杂性，因为我们试图描述这种编码风格，而不是去教它。 但是，在上面的摘录中，我们使用了许多高级概念：
* `F [_]`不是像`List [Int]`这样的具体类型，而是一种类型构造函数，当给定另一个类型时，它会产生具体类型。
* 日志记录和数据库建模为隐式参数，要求了解什么是隐式参数，如何将它们表示为上下文边界，如何表示隐式功能以及在何处定义隐式参数等
* 由于F类型是我们要求的功能以外的完全抽象的类型，因此我们通常需要其他功能来定义基本概念，例如顺序构成。 例如，这通常由tagless final 风格来描述的Monad。 显然，这需要对函数式编程概念有更高的了解，才能完全理解此代码。

其次，这种编程风格实际上并不能完全解决我们原来的问题，即删除依赖关系通过应用程序的多个级别显式传递的样板。
将方法所需的服务表示为上下文范围方面,tagless final无疑是一种改进，而且只有两个简单的服务。 但是我们之前曾说过，现代的应用程序可能依赖于十几个或更多个服务。
```
def run[F[_]: Logging : Database : Redis : Cassandra : Kafka : Persistence : Authentication
```

这只是八项服务，我们已经写完了所有这些服务，就填满了整个生产线。 想象一下，整个应用程序捆绑包在应用程序中需要向下10级，并为每个方法声明重复此类型签名！
我们希望能够通过执行以下操作来抽象出这组服务：
```
type Services = Logging with Database with Redis with Cassandra with Kafka with Persistence
```
然后，我们可以将所有方法签名重写为：
```
def run[F[_]: Services]: F[Unit] // does not compile
```
这将使我们能够一次定义应用程序所需的服务束，然后像在考虑程序逻辑的其他部分时一样在各处使用该定义。但这是行不通的，因为Scala不支持以这种方式在上下文范围内进行抽象。
第三，这种风格迫使我们以F数据类型而不是像ZIO这样的具体类型来对整个应用程序进行编程。
这意味着我们唯一可以使用的运算符是F所需的类型类上可用的运算符。使用 `无标签最终样式`的应用程序通常依赖于函数编程库来提供描述诸如顺序合成效果之类的功能的抽象，但是这些是通常不像直接在ZIO这样的具体数据类型上提供的运算符那样具有表现力。
因此，总的来说，无标签的最终风格是朝正确方向迈出的一步，但（1）通常仅适用于高级团队或能够在培训上投入大量资金的团队，（2）不能解决整个问题。
##  17.2.2 ReaderT
另一种方法是使用monad变压器。 Monad变形金刚允许在现有效果类型之上分层一些附加功能。
例如，如果我们使用Task作为基本效果类型来表示没有建模的效果，而没有任何环境要求，那么我们可以“分层”使用如下环境的功能：
```
  import zio._
  final case class ReaderT[R, A](run: R => Task[A]) {
    def provide(r: R): Task[A] = run(r)
  }

  object ReaderT {
    def environment[R]: Task[R] =
      ReaderT(r => Task.now(r))
  }
```
我们可以在ReaderT数据类型的级别上编写整个应用程序，以回到与ZIO类似的位置。
同样，这是朝正确方向迈出的一步，因为它基本上是在复制ZIO通过其环境类型提供的功能。回想一下，provide 和 environment 也是ZIO的环境类型的基本方法。
但是，在某些方面也存在不足。
首先，使用ReaderT的实现不如直接使用ZIO的实现有效。
像这样使用monad转换器将数据类型放在数据类型之上，因此，当我们的程序实际以这种方式评估程序时，还有许多包装和解包的附加步骤，这些步骤本身花费时间，并且妨碍了JVM进行其他优化的能力。
ZIO能够使用称为效果轮换的技术对高度优化的运行时中访问和提供环境以及我们已经视为单个数据类型的一部分的所有其他功能进行建模，该技术可产生比使用monad转换器更高的性能。
当然，有时性能差异并不重要，因为我们的应用程序的其他部分（例如等待网络呼叫）需要更长的时间。但是通常，我们希望堆栈的每个部分都尽可能高效，以便在较低层之上构建的较高层也可以尽可能高效。
其次，在monad转换器数据类型上定义的方法通常不如在具体效果类型上定义的方法那么多。
这是特别正确的，因为monad变压器通常被写成对具体效果类型通用。因此，ReaderT甚至不知道其中的类型是Task，而只是一个可能具有某些功能的`F [_]`。
这使得无法在ReaderT上定义需要F的特定功能（例如处理并发）的运算符。 因此，我们经常需要在ReaderT内部“挖掘”效果类型以执行操作，这又增加了另一层样板。
第三，对于monad转换器，类型推断通常会更差。
Scala编译器在推断更高种类的类型（例如，当`F [_]`为泛型时的ReaderT）时通常效率较低，这尤其如此，因为实现的monad转换器通常不会充分利用variance。
第四，monad转换器再次显着增加了代码的复杂性以及开发人员使用这种类型的代码需要提高工作效率的经验/培训水平。 我们在这里试图尽可能简化，但是monad转换器通常涉及更高种类的类型，并且需要类型类来描述基本效果类型的功能，因此需要更高的知识水平。
##  17.2.3 Implicits
隐式是已用于处理依赖项注入问题的另一种方法。 在讨论无标签的最终样式之前，我们已经看到了隐式的一些用法，但是隐式参数不必与无标签的final结合使用。
例如，Scala的Future所需的ExecutionContext是经常将隐式用于依赖项注入的一个区域。
```
import scala.concurrent.{ ExecutionContext, Future }
def sayHello(name: String)(implicit ec: ExecutionContext): Future[Unit] =
    Future(println(s"Hello, $name!"))
```
通过使ExecutionContext隐式，我们可以避免显式地在方法调用中传递它：
```
  def run(implicit ec : ExecutionContext) : Future [Unit] {
    for {
    _ <- sayHello ("Alice")
    _ <- sayHello ("Bob")} yield ()
  }
```

我们在这里可以看到，通过使ExecutionContext隐式化，我们避免了将它显式传递给sayHello调用的需要。
但是请注意，这仅减少了方法调用的样板，而不减少了方法声明的样板。 在run方法中调用sayHello时，我们不必指定ExecutionContext，但仍必须将其作为sayHello签名中的隐式参数列出。
使用单个隐式参数（例如ExecutionContext）并不太糟，尽管这确实意味着通常每个方法签名都需要一个隐式ExecutionContext！
但是，如果我们需要传递十二种不同的服务怎么办？
就像上面在讨论无标记final时一样，Scala不允许我们对隐式参数进行抽象，因此我们必须在每个方法声明中列出所有十二种服务，这是很多样板！
以这种方式使用隐式方法也带来了一个风险，即很难确定我们的服务的实际来源。
通常，最佳实践是类型应只包含一个隐式实例。 但是在给定的应用程序中可能有多个ExecutionContext值（例如，一个用于异步任务，另一个用于阻塞任务）。
这可能会导致我们在错误的ExecutionContext上意外运行任务的风险，从而导致性能降低甚至出现死锁。 这也使重构更加困难，因为将代码复制到另一个文件中可能会更改范围和代码含义中的隐式。