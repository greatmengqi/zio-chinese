# 17.5 组合环境类型
访问环境时要了解的另一重要事项是不同效果的环境要求是如何构成的。
例如，假设我们有一种需要数据库服务的效果，而有一种需要日志服务的效果。 如果我们将它们组合在一起，组合的效果将需要什么服务？
```
  trait Database 
  trait Logging

  def getName(userId: Long): ZIO[Database, Throwable, String] = ???
  
  def logLine(line: String): ZIO[Logging, Nothing, Unit] = ???
  
  def getAndLogName(userId: Long): ZIO[Database with Logging, Throwable, String] = for {
    name <- getName(userId)
    _ <- logLine(s"Got $name associated with $userId from database")
  } yield name
```
答案是环境类型将是“带日志记录的数据库”。
Scala中的A with B语法描述了一个交集类型，该类型提供了A的所有功能以及B的所有功能。因此，带日志的数据库类型描述了一个环境，该环境支持数据库上的所有方法，例如读取并写入数据库，以及有关Logging的所有方法，例如记录行。
这是有道理的，因为要运行getAndLogName，我们最终将不得不调用需要数据库功能的getName和需要日志记录功能的logLine。因此，要运行整个效果，我们将需要提供同时实现数据库和日志记录功能的服务。
思考环境的一种有用方法是效果需要的一组服务。这有几个含义。
首先，就像集合中的元素一样，环境中的服务顺序并不重要，因此我们可以根据需要经常对环境类型的类型签名中的服务进行重新排序。
```
lazy val clockConsoleRandom: ZIO[Clock with Console with Random, Nothing, Unit] = ???
lazy val randomConsoleClock: ZIO[Random with Console with Clock, Nothing, Unit] = clockConsoleRandom
```
第二个原因是，由于集合没有重复项，因此多次在环境签名中包含相同服务是无关紧要的，可以添加或丢弃。

```
lazy val console1: ZIO[Console, Nothing, Unit] = ???
lazy val console2: ZIO[Console with Console, Nothing, Unit] = console1
lazy val console3: ZIO[Console, Nothing, Unit] = console2
```
第三个是，由于R是协变的，所以Any是一个 元 元素。 因此，您可以根据需要在环境中在类型签名中的交集类型中添加或删除“任意”，这将始终意味着同一件事。
例如：
```
lazy val effect1: ZIO[Console, Nothing, Unit] = ???
lazy val effect2: ZIO[Console with Any, Nothing, Unit] = effect
lazy val stillTheSame: ZIO[Console, Nothing, Unit] = effect
```