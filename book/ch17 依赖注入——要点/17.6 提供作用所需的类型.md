# 17.6 提供作用所需的类型
到目前为止，我们已经描述了访问环境中的服务并使用它们所需的一切，例如访问数据库向其中写入内容。 但是，实际上我们如何为效果提供所需的服务，以便我们可以运行它们？
最简单的方法是Provide运算符，它在整个所需环境中提供效果。
```
trait ZIO[-R, +E, +A] {
    def provide(r: R): IO[E, A]
}
```
例如，我们可以提供一种需要实时运行数据库的效果
像这样的实现：
```
  trait Database
  val database: Database = ???
  
  val effect1: ZIO[Database, Nothing, Unit] = ???
  
  val effect2: ZIO[Any, Nothing, Unit] = effect.provide(database)
  // effect2 has been provided with all its required services and is ready to be run
```
还有一个providerSome运算符，可在其部分所需环境中提供效果。
```
trait ZIO[-R, +E, +A] {
    def provideSome[R1](f: R1 => R): ZIO[R1, E, R]
}
```
但是，此运算符要求我们从新效果仍需要的服务集中手动构建效果所需的全部服务。 例如，如果我们需要一个同时需要数据库和日志记录服务的效果，则可以使用ProvideSome来仅提供数据库服务，如下所示：
```
  trait Database
  trait Logging
  val effect3: ZIO[Database with Logging, Nothing, Unit] = ???
  // 先提供database ，后面再提供logging
  val effect4: ZIO[Logging, Nothing, Unit] = effect3.provideSome {
    logging => ??? // we need to provide a way to create a `Database with Logging` service given a `Log
  }
```
在下一章中，我们将看到如何将服务组合在一起，但是为了避免自己做这些，我们通常使用另一组运算符，provideLayer和provideSomeLayer，而不是直接使用provide和provideSome。
ProvideLayer的稍微简化的签名是：
```
  object ZIO {
    final def provideLayer[E1 >: E, R0, R1](layer: ZLayer[R0, E1, R]): ZIO[R0, E1, A] =
      ???
  }
```
ProvideLayer运算符是我们研究的第一个使用ZLayer数据类型的运算符，因此，让我们现在来看一下它，以了解它以及它如何适合解决依赖项注入问题。
现在，我们将介绍ZLayer，并在这里了解如何作为现有服务的用户使用ZLayer。在下一章中，我们将在ZLayer上花费更多的时间，包括ZLayer的内部实现以及如何使用它来构建和组合自己的服务。
`ZLayer [-RIn，+ E，+ ROut]`是构建一组服务的秘诀。它需要一组输入服务RIn，并且可能因错误E类型而失败，也可能因一组ROut类型的输出服务而成功。
从上面的类型签名可以看到，层本身可以具有自己的依赖性，因此我们可以例如使用`ZLayer [Logging，Nothing，Logging with Database]`，这将是构建一组Logging和Database服务的秘诀提供了记录服务。但是，我们通常最终希望拥有一个RIn类型为任意层的图层，这表明该图层不再具有任何其他依赖项。
ZLayer与ZManaged相似，它是一种专门的ZIO效果，旨在解决特定领域的问题。 ZManaged旨在解决资源处理问题，而ZLayer旨在解决构建应用程序所需依赖关系的问题。
因此，您所了解的有关ZIO和ZManaged的几乎所有内容都将转移到ZLayer。
特别是，层只是用于构建服务的蓝图，因此，直到我们构建层（通常通过使用provideLayer运算符）后，才真正构建任何服务。
回到为我们的效果提供所需的数据库服务的示例，使用ProvideLayer看起来像这样：
```
val databaseLayer: ZLayer[Any, Nothing, Database] = ???
val effect5: ZIO[Database, Nothing, Unit] = ???
val effect6: ZIO[Any, Nothing, Unit] = effect5.provideLayer(databaseLayer)
```
在实践中，这通常是我们与环境中的服务一起工作的方式。
服务的实现者除了定义服务接口之外，还将创建一层或多层来构建服务的实现。作为服务的用户，我们将使用ProvideLayer来构建应用程序所需的服务，并将其提供给我们的应用程序。
这样做的一个好处是，它允许我们描述服务创建时可能会使用效果并且需要安全获取和释放资源的服务。
例如，到目前为止，我们一直在谈论数据库服务，好像它只是可以在其上调用方法的全局可用的东西一样。但实际上，创建实时数据库服务可能需要执行一些效果，例如打开数据库连接和完成终结（例如关闭该连接）。
ZLayer让我们使用我们为ZIO和ZManaged学习的现有工具来描述所有这些事情。
我们将在下一章中详细了解这一点，但是现在您可以将ProvideLayer视为类似于ZManaged上的use运算符。当我们在效果上调用provideLayer时，无论效果如何完成，都会在效果执行之前立即获取效果所需的服务，并在效果完成之后立即释放效果。
使用图层的另一个优点是，它们使我们可以更轻松地使用ProvideSomeLayer运算符仅提供部分环境。
让我们回到上面讨论的情况，即我们需要一个数据库服务和一个日志记录服务。我们现在想提供数据库服务的具体实现，但是我们希望推迟提供日志记录服务，直到应用程序的更高层次。
使用ZLayer，此问题变得非常简单：
```
trait Database
trait Logging
val databaseLayer: ZLayer[Any, Nothing, Database] = ???
val effect1: ZIO[Database with Logging, Nothing, Unit] = ???
val effect2: ZIO[Logging, Nothing, Unit] = effect1.provideSomeLayer[Logging](databaseLayer)
```
现在，我们无需为如何将数据库服务与日志记录服务结合以获得具有日志记录服务的数据库提供任何特殊的逻辑。 ZLayer知道如何为我们自动做到这一点。
我们将在下一章中看到如何定义服务以使之成为可能的工作。奖励是，尽管现在部分提供这样的图层非常方便。
关于ProvideSomeLayer要注意的一件事是，它是ZIO中少数需要手动指定type参数的运算符之一。不幸的是，Scala编译器无法从效果所需要的服务集中消除我们提供的服务，因此我们必须自己做，尽管编译器能够验证指定类型的合理性。
使用provideSomeLayer运算符时，您指定的类型应该是您“落后”的类型，即您不提供的类型。
例如，在上面的示例中，我们确实提供了`SomeLayer [Logging]（databaseLayer`。数据库服务是我们提供的服务，因此日志记录服务是尚待解决的依赖关系以及我们要指定的类型。
如果您发现自己多次“落后”于同一环境，则可以创建一个专门的运算符，该运算符始终将其指定为您要留下的环境。
例如，ZIO包含定义为`ProvideSomeLayer [ZEnv]`的ProvideCustomLayer运算符。这要求调用者指定一个层，该层提供效果所需的任何服务，这些服务不属于ZIO实现的默认服务。
```
 val effect1: ZIO[Database with Logging with Clock with Console, Nothing, Unit] = ???
  // provides all services that are not part of standard ZIO environment
  val customLayer: ZLayer[Any, Nothing, Database with Logging] = ???
  // effect now only requires default services
  val effect2: ZIO[Clock with Console, Nothing, Unit] = effect1.provideCustomLayer(customLayer)
```
同样，ZIO Test实现了ProvideCustomLayer变体，要求用户指定一个层，该层提供不属于ZIO Test提供的TestEnvironment的所有服务。
