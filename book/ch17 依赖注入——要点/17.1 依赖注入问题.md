# 17.1 依赖注入问题
现代应用程序几乎总是依赖于一个或多个服务，这些服务提供了应用程序运行所必需的功能，但不是由应用程序本身实现的。例如，一个简单的应用程序可能依赖于允许从中读取和写入值的数据库服务。 它们到数据库以及允许在应用程序运行时记录信息的记录服务。 实际上，现代应用程序通常会比此依赖更多的服务。
为了实现模块的松散耦合，我们不想将应用程序硬编码到特定的数据库或日志服务。 相反，我们希望能够指定我们的应用程序依赖于某些数据库或日志记录服务。
从概念上讲，我们希望能够说：
```
  import zio._ 
  trait Database
  trait Logging
  trait Application {
    def run(database: Database, logging: Logging): UIO[Unit]
  }
```
也就是说，数据库和日志记录表示我们的应用程序可以与之交互的接口，并且要运行我们的程序，我们可以提供任何提供该接口功能的实现。
例如，日志记录服务可能提供记录任意行的功能。
```
trait Logging {
    def logLine(line: String): UIO[Unit]
}
```
然后，我们可以在应用程序代码中的任何位置调用logLine方法以记录一行。 我们可以通过提供实现logLine的Logging服务的任何实现来运行我们的程序。
这种体系结构具有多个优点。
首先，它可以提高可测试性，因为我们可以为提供已知输入并允许我们验证预期输出的每项服务提供测试实现。
如果我们对应用程序进行硬编码以将输出打印到实时控制台，则将无法以编程方式验证控制台的输出。 但是，如果我们将控制台服务表示为依赖项，那么我们可以提供一个测试实现，它将所有输出写入可以检查的数据结构中。
其次，它使我们以后更容易切换一个或多个依赖项。
如果我们对数据库的依赖关系进行硬编码，那么我们很可能将依赖于所使用的数据库的各种实现特定细节，如果我们想更改所使用的数据库，则可能需要重构整个应用程序。另一方面，如果将数据库抽象为服务，则我们应该能够使用其他数据库服务，而无需更改应用程序代码。
第三，它使这些服务的开发人员更容易独立开发它们。
在诸如日志记录之类的任何领域中，都有关于如何实现日志记录服务的各种详细信息。该接口实质上是服务的公共API，并且由于用户仅依赖该接口，因此服务的实现者可以自由地更改其代码的任何其他方面，只要他们实现该接口即可。
因此，我们知道，对应用程序的依赖关系进行显式建模很有价值。那么依赖注入问题是什么？
依赖项注入问题本质上是一个“管道”问题。我们如何从应用程序的顶部到我们实际使用它的地方获取应用程序的依赖关系？
在大型应用程序中，在我们的应用程序的顶部与实际调用服务中的方法之间可能存在十个方法调用级别。我们可以通过这些方法调用中的每个作为另一个参数来显式传递服务，但这很快就变成了样板，尤其是当我们可能有十几个或更多应用程序依赖的不同服务时。
当然，我们可以在我们的应用程序中全局公开这些服务中的每一个，但随后我们将失去查看应用程序的哪些部分取决于哪些服务或潜在地为应用程序的某些部分提供不同或修改的服务的全部能力。