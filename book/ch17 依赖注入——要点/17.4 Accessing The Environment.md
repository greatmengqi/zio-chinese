# 17.4 Accessing The Environment
我们使用`access`，`accessM`和`environment`运算符访问环境以对其进行处理。
在某种程度上，environment是最根本的。 它的签名是：
```
  object ZIO {
    def environment[R]: ZIO[R, Nothing, R] =
      ???
  }
```
environment操作从环境获取服务，以便我们可以对其进行处理。 例如，我们可以访问环境中的日志记录服务，以便我们可以记录某些内容。
```
def logLine(line: String): ZIO[Logging, Nothing, Unit] = ZIO.environment[Logging].flatMap(service => service.logLine(line))
```
access和accessM运算符只是将从环境中获取服务以及对其进行处理的操作捆绑到一个运算符中。
```
  object ZIO {
    def access[R, A](f: R => A): ZIO[R, Nothing, A] =
      ZIO.environment.map(f)
    def accessM[R, E, A](f: R => ZIO[R, E, A]): ZIO[R, E, A] =
      ZIO.environment.flatMap(f)
  }
```
最初人们了解环境时，有时会令人们不寒而栗的一件事是，当我们使用 environment, access, 或者 accessM操作时，我们所使用的服务尚不存在。
例如，考虑：
```
def logLine(line: String): ZIO[Logging, Nothing, Unit] = ZIO.environment[Logging].flatMap(service => service.logLine(line))
```
我们在方法实现中使用了Logging服务，但尚未提供。效果的Logging环境类型表明我们仍然“欠”该效果Logging服务。
environment, access, 或者 accessM操作允许我们针对服务写“检查”，说“让我对这项服务做些事情，我保证您以后会提供它的实际实现”。除非这次，Scala编译器将确保我们偿还债务，因为它不会让我们在不提供所需的所有服务的情况下运行 effect。
让我们在不提供所需的所有服务的情况下运行这种效果。
推迟提供服务的想法实际上是依赖项注入问题的核心。我们希望能够像使用它们一样使用这些服务来编写我们的代码，但是我们希望推迟将它们实际提供给我们的应用程序的更高级别，而环境类型可以让我们做到这一点。。
需要注意的另一件事是，这些是ZIO中极少数需要经常指定环境类型的运算符。
原因是当我们调用环境或访问时，理论上我们可以访问该环境中的任何服务。我们可能会完全访问Logging，Database或其他内容。有时，可以通过我们在其上调用的方法来推断正在访问的环境的类型，但是Scala编译器通常以“从左到右”的方式工作。
因此，准备好指定使用这些运算符时要访问的服务的类型。